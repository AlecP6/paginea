generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String         @id @default(uuid())
  email            String         @unique
  username         String         @unique
  password         String
  firstName        String?
  lastName         String?
  bio              String?
  avatar           String?
  role             UserRole       @default(USER)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  bookReviews      BookReview[]
  comments         Comment[]
  friendsInitiated Friendship[]   @relation("FriendshipInitiator")
  friendsReceived  Friendship[]   @relation("FriendshipReceiver")
  likes            Like[]
  posts            Post[]
  reports          Report[]
  sentMessages     Message[]      @relation("MessageSender")
  receivedMessages Message[]      @relation("MessageReceiver")
  conversations1   Conversation[] @relation("ConversationUser1")
  conversations2   Conversation[] @relation("ConversationUser2")

  @@map("users")
}

model Friendship {
  id          String           @id @default(uuid())
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  initiatorId String
  receiverId  String
  initiator   User             @relation("FriendshipInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  receiver    User             @relation("FriendshipReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([initiatorId, receiverId])
  @@map("friendships")
}

model Post {
  id        String    @id @default(uuid())
  content   String
  type      PostType  @default(PUBLIC)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  authorId  String
  comments  Comment[]
  likes     Like[]
  reports   Report[]
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@map("posts")
}

model BookReview {
  id         String        @id @default(uuid())
  bookTitle  String
  bookAuthor String
  bookIsbn   String?
  bookCover  String?
  rating     Int
  review     String?
  status     ReadingStatus @default(READ)
  startedAt  DateTime?
  finishedAt DateTime?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  authorId   String
  author     User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments   Comment[]
  likes      Like[]
  reports    Report[]

  @@map("book_reviews")
}

model Comment {
  id           String      @id @default(uuid())
  content      String
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  authorId     String
  postId       String?
  bookReviewId String?
  author       User        @relation(fields: [authorId], references: [id], onDelete: Cascade)
  bookReview   BookReview? @relation(fields: [bookReviewId], references: [id], onDelete: Cascade)
  post         Post?       @relation(fields: [postId], references: [id], onDelete: Cascade)
  reports      Report[]

  @@map("comments")
}

model Like {
  id           String      @id @default(uuid())
  createdAt    DateTime    @default(now())
  userId       String
  postId       String?
  bookReviewId String?
  bookReview   BookReview? @relation(fields: [bookReviewId], references: [id], onDelete: Cascade)
  post         Post?       @relation(fields: [postId], references: [id], onDelete: Cascade)
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@unique([userId, bookReviewId])
  @@map("likes")
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

enum PostType {
  PUBLIC
  FRIENDS
}

enum ReadingStatus {
  WANT_TO_READ
  READING
  READ
  ABANDONED
}

enum UserRole {
  USER
  ADMIN
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  REJECTED
}

model Report {
  id            String        @id @default(uuid())
  reason        String
  description   String?
  status        ReportStatus  @default(PENDING)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  reporterId    String
  reporter      User          @relation(fields: [reporterId], references: [id], onDelete: Cascade)
  postId        String?
  post          Post?         @relation(fields: [postId], references: [id], onDelete: Cascade)
  commentId     String?
  comment       Comment?      @relation(fields: [commentId], references: [id], onDelete: Cascade)
  bookReviewId  String?
  bookReview    BookReview?   @relation(fields: [bookReviewId], references: [id], onDelete: Cascade)

  @@map("reports")
}

model Conversation {
  id        String    @id @default(uuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user1Id   String
  user2Id   String
  user1     User      @relation("ConversationUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2     User      @relation("ConversationUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages  Message[]

  @@unique([user1Id, user2Id])
  @@map("conversations")
}

model Message {
  id             String       @id @default(uuid())
  content        String
  isRead         Boolean      @default(false)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  senderId       String
  receiverId     String
  conversationId String
  sender         User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver       User         @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@map("messages")
}
